# -*- coding: utf-8 -*-
"""Assessment-Task-No3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-L9JjcWU08_2R-Q2Tb_wKP8ZXEwNfM89

# **1. Unification**
"""

def unify(p1, p2):
    f1, f2 = p1.split("(")[0], p2.split("(")[0]
    if f1 != f2: return "Cannot be unified"

    a1, a2 = p1[p1.find("(")+1:-1].split(","), p2[p2.find("(")+1:-1].split(",")
    if len(a1) != len(a2): return "Cannot be unified"

    subs = {}
    for x, y in zip(a1, a2):
        x, y = x.strip(), y.strip()
        if x == y: continue
        if x.islower(): subs[x] = y
        elif y.islower(): subs[y] = x
        else: return "Cannot be unified"

    return subs or "Already unified"

# Test
print(unify("Eligible(x)", "Eligible(Ana)"))

"""# **2. Forward Chaining**"""

facts = [
    "HighGrades(Juan)",
    "Applied(Juan)",
    "HighGrades(Maria)",
    "DidNotApply(Maria)",
    "StudentLeader(Carlos)",
    "NoHighGrades(Carlos)",
    "HighGrades(Ana)",
    "StudentLeader(Ana)",
    "Applied(Ana)",
]

rules = [
    (["HighGrades", "StudentLeader", "Applied"], "Eligible"),
    (["Eligible"], "Scholarship"),
    (["Scholarship"], "FinancialSupport"),
]

seen = set(facts)
ordered_facts = list(facts)

persons = []
for f in facts:
    name = f[f.find("(")+1:-1]
    if name not in persons:
        persons.append(name)

print("~~~~~ Forward Chaining Derivation ~~~~~~~~")

changed = True
while changed:
    changed = False
    for person in persons:
        for antecedents, consequent in rules:
            if all(f"{ant}({person})" in seen for ant in antecedents):
                new_fact = f"{consequent}({person})"
                if new_fact not in seen:
                    seen.add(new_fact)
                    ordered_facts.append(new_fact)
                    changed = True
                    print(f"Derived {new_fact} because", " âˆ§ ".join(f"{ant}({person})" for ant in antecedents))

print("\n------- Final Facts (preserved order) ------")
for f in ordered_facts:
    print("-", f)

initial = set(facts)
derived_juan = [f for f in ordered_facts if f.endswith("(Juan)") and f not in initial]
derived_ana  = [f for f in ordered_facts if f.endswith("(Ana)") and f not in initial]

print("\nNew facts derived for Juan:", derived_juan or "None")
print("New facts derived for Ana:", derived_ana or "None")

"""# **3. Backward Chaining**"""

facts = {
    "HighGrades(Juan)", "Applied(Juan)",
    "HighGrades(Maria)", "DidNotApply(Maria)",
    "StudentLeader(Carlos)", "NoHighGrades(Carlos)",
    "HighGrades(Ana)", "StudentLeader(Ana)", "Applied(Ana)"
}

def prove(goal):
    if goal in facts: return True

    if goal.startswith("Eligible("):
        name = goal[goal.find("(")+1:-1]
        return all(p.replace("x", name) in facts for p in
                   ["HighGrades(x)", "StudentLeader(x)", "Applied(x)"])

    if goal.startswith("Scholarship("):
        name = goal[goal.find("(")+1:-1]
        return prove(f"Eligible({name})")

    if goal.startswith("FinancialSupport("):
        name = goal[goal.find("(")+1:-1]
        return prove(f"Scholarship({name})")

    return False

print("Scholarship(Maria)?", prove("Scholarship(Maria)"))
print("FinancialSupport(Ana)?", prove("FinancialSupport(Ana)"))

"""**Reflection:**
Logical reasoning is important in AI and daily life because it helps us reach correct conclusions from clear facts and rules. Methods like unification, forward chaining, and backward chaining show the step-by-step reasoning process, making outcomes transparent and justifiable. Whether in automated systems or real-world issue solving, this lowers errors, increases confidence in outcomes, and guarantees decisions are consistent and equitable.
"""